<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body style="width: 100vw; height: 100vh; margin: 0">
    <script>
      const HEIGHT = 1000;
      const WIDTH = 2000;
      const CENTER_X = WIDTH / 2;
      const CENTER_Y = HEIGHT / 2;

      const BOX_WIDTH = 200;
      const BOX_HEIGHT = 50;

      const STROKE_COLOR = "black";
      const STROKE_WIDTH = 2;
      const BLUE = "#4a90e2";
      const LIGHT_BLUE = "#20a0f3";
      const FILL_COLOR = LIGHT_BLUE;
      const TEXT_COLOR = "#333";

      function Graph() {
        const graph = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        graph.setAttribute("viewBox", `0 0 ${WIDTH} ${HEIGHT}`);
        graph.setAttribute("xmlns", "http://www.w3.org/2000/svg");

        graph.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

        graph.style.border = "1px solid black";
        graph.style.height = "98vh";

        return graph;
      }

      function Box(x, y) {
        // add a box to test the graph
        const box = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );

        box.setAttribute("x", x);
        box.setAttribute("y", y);
        box.setAttribute("width", BOX_WIDTH);
        box.setAttribute("height", BOX_HEIGHT);
        box.setAttribute("fill", FILL_COLOR);
        box.setAttribute("stroke", STROKE_COLOR);
        box.setAttribute("stroke-width", STROKE_WIDTH);
        return box;
      }
      function Text(x, y, textContent) {
        const text = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        text.setAttribute("x", x);
        text.setAttribute("y", y);
        text.setAttribute("fill", TEXT_COLOR);
        text.textContent = textContent;
        return text;
      }

      function TextBox(x, y, textContent) {
        const box = Box(x, y);
        const text = Text(x + 5, y + 30, textContent);
        return { box, text };
      }
      const graph = Graph();
      document.body.appendChild(graph);

      const ROOT_X = CENTER_X - BOX_WIDTH / 2;
      const ROOT_Y = CENTER_Y - BOX_HEIGHT / 2;
      const rootBox = Box(ROOT_X, ROOT_Y);
      graph.appendChild(rootBox);

      const rootText = Text(ROOT_X + 5, ROOT_Y + 30, "A");
      graph.appendChild(rootText);

      const startNode = "A";
      const nodes = [
        { id: "A", next: new Set(["B", "C", "D", "E"]) },
        { id: "B", next: new Set(["G", "H"]) },
        { id: "C", next: new Set(["I", "J"]) },
        { id: "D", next: new Set(["K", "L"]) },
        { id: "E", next: new Set(["E"]) },
        { id: "F", next: new Set(["G"]) },
        { id: "G", next: new Set([]) },
      ];


      const MARGIN_FROM_ROOT = BOX_WIDTH * 2;
      const LEFT_OF_ROOT = ROOT_X - MARGIN_FROM_ROOT;
      const RIGHT_OF_ROOT = ROOT_X + MARGIN_FROM_ROOT;
      const MARGIN_BOX_TO_BOX = BOX_HEIGHT * 2;

      const fakeRadialCoordinateTestCases = [
        { x: LEFT_OF_ROOT, y: ROOT_Y + MARGIN_BOX_TO_BOX * 0 }, // left of the root (only x and y)
        { x: RIGHT_OF_ROOT, y: ROOT_Y - MARGIN_BOX_TO_BOX * 0 }, // right of the root (only x and y)
        { x: RIGHT_OF_ROOT, y: ROOT_Y + MARGIN_BOX_TO_BOX * 1 }, // below the root (only x and y)
        { x: LEFT_OF_ROOT, y: ROOT_Y - MARGIN_BOX_TO_BOX * 1 }, // above the root (only x and y)
        { x: LEFT_OF_ROOT, y: ROOT_Y + MARGIN_BOX_TO_BOX * 1 }, // below the root (only x and y)
        { x: RIGHT_OF_ROOT, y: ROOT_Y - MARGIN_BOX_TO_BOX * 1 }, // above the root (only x and y)
        { x: RIGHT_OF_ROOT, y: ROOT_Y + MARGIN_BOX_TO_BOX * 2 }, // below the root (only x and y)
        { x: LEFT_OF_ROOT, y: ROOT_Y - MARGIN_BOX_TO_BOX * 2 }, // below the root (only x and y)
      ];

      function nextFakeRadialCoordinate(n) {
        const even = n % 2 === 0;
        const odd = n % 2 === 1;

        // if we are 0 we are even and we would first go to the right side
        const side = odd ? "right" : "left";
        const x = side === "left" ? LEFT_OF_ROOT : RIGHT_OF_ROOT;
        // for the first 2 nodes we stay at the same height as the root node
        const is_centered = n < 2;
        if (is_centered) {
          console.log("centered, " + side);
          return {
            x: x,
            y: ROOT_Y,
          };
        }

        // ...existing code...
        const multiplier = Math.floor((n - 2) / 4) + 1;
        // ...existing code...

        const verticalAlignment = n % 4 === 0 || n % 4 === 1 ? "top" : "bottom";

        console.log(verticalAlignment, side);
        const y =
          verticalAlignment === "top"
            ? ROOT_Y - MARGIN_BOX_TO_BOX * multiplier
            : ROOT_Y + MARGIN_BOX_TO_BOX * multiplier;
        return { x, y };
      }

   
          const firstLevelChildren = nodes.find(
        (node) => node.id === startNode
      ).next;
      console.log("firstLevelChildren", firstLevelChildren);
      const numberOfFirstLevelChildren = firstLevelChildren.size;
      console.log("numberOfFirstLevelChildren", numberOfFirstLevelChildren);

        const firstLevelChildrenArray = Array.from(firstLevelChildren);
        console.log("firstLevelChildrenArray", firstLevelChildrenArray);

      firstLevelChildrenArray.forEach((child, index) => {
        const coord = nextFakeRadialCoordinate(index);
        const { x, y } = coord;
        console.log("nextFakeRadialCoordinate", coord);
        const childBox = TextBox(x, y, child);
        graph.appendChild(childBox.box);
        graph.appendChild(childBox.text);

      })

    </script>
  </body>
</html>
